var logger = require('../../logger'),
	colors = require('colors'),
	crypto = require('crypto'),
	u = require('../../util'),
	querystring = require('querystring'),
	child_process = require('child_process'),
	urllib = require('url'),
	path = require('path'),
	fs = require('fs'),
	fstream = require("fstream"),
	tar = require("tar"),
	zlib = require("zlib"),
	temp = require('temp'),
	os = require('os'),
	wrench = require('wrench'),
	hserver = null,
	m,
	timer,
	statsReportOpts,
	requests = [],
	reportServerConnectionRefused = 0,
	totalRequests = 0,
	totalRequestDataSize = 0,
	totalResponseDataSize = 0,
	requestsSinceLastSend = 0,
	dataSizeSinceLastSend = 0,
	responseSizeSinceLastSend = 0,
	totalRequestDuration = 0,
	requestDurationLastSend = 0,
	requestsByAPI = {},
	requests = [],
	metadata,
	current = 0,
	controller,
	controllers = 
	[
		require('./aws'),
		require('./local') // this should always be last
	]
;

/**
 * the goal of this module is to provider a delegate
 * to a specific server plugin that handles the specific
 * machine/environment specific implementations of the 
 * backend server
 */

function generateAuthToken (path, ipaddress, port)
{
	var key = 's'+port+'@'+ipaddress+'s';
	path = path.split('?')[0];
	return 'Stratus '+crypto.createHmac('MD5', key).update(path).digest('hex')
};


function findNextController(m, callback)
{
	if (current >= controllers.length)
	{
		callback(new Error('no suitable server controller found'));
	}
	else if (!controller)
	{
		var c = controllers[current++];
		c.setup(m, function(enabled,metadata)
		{
			if (enabled)
			{
				controller = c;
				logger.debug('Using server controller: '+controller.name.blue);
				callback(null,metadata);
			}
			else
			{
				findNextController(m, callback);
			}
		});
	}
}

function reportStats(data)
{
	if(!statsReportOpts)
	{
		var globalConfig = u.getGlobalConfig(), defaultConfig = u.getDefaultConfig();
		var url = (globalConfig.publishHost || defaultConfig.publishHost) + ':' +
			(globalConfig.publishPort || defaultConfig.publishPort) + '/node-report/'+m.myIP+'/'+m.port;

		var opts = urllib.parse(url);
		opts.method = 'POST';
		if (opts.protocol == 'http:') {
			hserver = require('http');
		} else if (opts.protocol == 'https:') {
			hserver = require('https');
		} else {
			u.die('Unrecognized protocol. Please check your configuration items.');
		}
		var auth = generateAuthToken(opts.path,m.myIP,m.port);
		opts.headers = {'Content-Type':'application/json','Authorization':auth};
		statsReportOpts = opts;
		logger.debug('sending to ' + url);
	}

	// add our server metadata if we have any
	data.metadata = metadata || {};

	// send POST request
	hserver.request(statsReportOpts,function(res)
	{
		// reset once connected
		reportServerConnectionRefused=0;
		var data='';
		res.setEncoding('utf-8');
		res.on('data',function(buf)
		{
			data+=buf;
		});
		res.on('end',function()
		{
			var result = JSON.parse(data);
			if (result.success && result.pendingUpdate)
			{
				// this node needs to be updated
				logger.info('Required update detected');
				if (m.netBoot)
				{
					// if net booting, we are going to create
					// a new temp directory each time
					temp.mkdir('nettle',function(err,dir)
					{
						if (err)
						{
							u.die('error creating temp directory. '+e);
						}
						m.publishPath = dir;
						logger.debug('publish path set to '+dir);
						performUpdate(false);

						function rmdir()
						{
							wrench.rmdirSyncRecursive(dir,true);
						}
						process.on('SIGINT', rmdir);
						process.on('exit',rmdir);

					});
				}
				else
				{
					performUpdate(false);
				}
			}
		});
	})
	.on('error',function(e)
	{
		if (e.code == 'ECONNREFUSED')
		{
			// connection refused, server must be down
			++reportServerConnectionRefused == 1 && logger.warn('Error connecting to report server. Will report this only once.');
			return;
		}
		logger.error('Error reporting stats. '+e);
	})
	.end(JSON.stringify(data));
}

function getSwap(cb)
{
	if (os.platform()=='darwin')
	{
		// we find the available storage first on all the mounts
		child_process.exec('vm_stat|grep Pages',function(err,stdout,stderr)
		{
			if (err)
			{
				logger.error(err);
				return;
			}
			var swap = {};
			_.each(stdout.split('\n'),function(line)
			{
				if (!line) return;
				var tok = line.split(':');
				//4096 per page, the values are pages
				swap[u.trim(tok[0]).replace(':')] = 4096 * parseInt(u.trim(tok[1]).replace('.',''));
			});
			var free = swap['Pages free'], active = swap['Pages active'];
			cb({
				'free':free,
				'active':active
			});
		});
	}
	else if (os.platform()=='linux')
	{
		// we find the available storage first on all the mounts
		child_process.exec('cat /proc/meminfo | grep Swap',function(err,stdout,stderr)
		{
			if (err)
			{
				logger.error(err);
				return;
			}
			var swap = {};
			_.each(stdout.split('\n'),function(line)
			{
				if (!line) return;
				var tok = line.split(':');
				// kB so we need to convert to bytes
				swap[u.trim(tok[0]).replace(':')] = 1000 * parseInt(u.trim(tok[1]).replace(' kB',''));
			});
			var free = swap['SwapFree'], active = swap['SwapCached'];
			cb({
				'free':free,
				'active':active
			});
		});
	}
	else
	{
		// not supported
		cb({
			'free':0,
			'active':0
		});
	}
}

function getDiskUsage(cb)
{
	// we find the available storage first on all the mounts
	child_process.exec('/bin/df -l',function(err,stdout,stderr)
	{
		if (err)
		{
			logger.error(err);
			return;
		}
		var storage = [];
		_.each(stdout.split('\n').splice(1),function(line)
		{
			if (line)
			{
				var tokens = line.split(' ');
				var entries = _.filter(tokens,function(t)
				{
					return t;
				});
				var disk = entries[0],
					used = entries[2], 
					avail = entries[3],
					capacity = parseInt(entries[4].replace('%','')),
					mount = entries.splice(5).join(' ');
				storage.push({
					disk:disk,
					used:used,
					avail:avail,
					capacity: capacity?capacity/100:0,
					mount:mount
				});
			}
		});
		cb(storage);
	});
}

function startMonitoring(interval_in_ms)
{
	if (timer)
	{
		clearInterval(timer);
	}
	function sendProcessStats()
	{
		getDiskUsage(function(storage)
		{
			getSwap(function(swap)
			{
				// scoop of our deployed versions
				var svs = [],
					latest = null;
				for (var v in m.services)
				{
					if (v!='latest')
					{
						svs.push(m.services[v].version);
					}
					else
					{
						latest = m.services[v];
					}
				}

				var data = 
				{
					'ver': 1,
					'type' : 'process',
					'name': latest ? latest.name : null,
					'appid': latest ? latest.config.appid : null,
					'version': latest ? latest.config.version : null,
					'versions': svs,
					'date' : new Date,
					'os': {
						'uptime': os.uptime(),
						'load': os.loadavg(),
						'cpus': os.cpus(),
						'release':os.release(),
						'type':os.type(),
						'arch':os.arch(),
						'platform':os.platform(),
						'ipaddress':m.myIP,
						'hostname':os.hostname(),
					},
					'process': {
						'uptime': process.uptime(),
						'memory': _.extend(process.memoryUsage(), {'free':os.freemem(),'total':os.totalmem()}),
						'pid': process.pid,
						'swap': swap
					},
					'bandwidth': {
						'request':{
							'total':totalRequestDataSize,
							'incremental':dataSizeSinceLastSend
						},
						'response': {
							'total': totalResponseDataSize,
							'incremental': responseSizeSinceLastSend
						}
					},
					'apis': {
						'total':totalRequests,
						'incremental':requestsSinceLastSend,
						'requests':requestsByAPI
					},
					'latency': {
						'total': totalRequestDuration,
						'incremental':requestDurationLastSend
					},
					'storage': storage,
					'requests': requests
				};
				// console.log(JSON.stringify(data))
				// reset each time
				dataSizeSinceLastSend = requestsSinceLastSend = 0;
				requestDurationLastSend = responseSizeSinceLastSend = 0;
				requests = [];
				reportStats(data);
			});
		});
	}
	timer = setInterval(sendProcessStats,interval_in_ms);
	sendProcessStats();
}

function startReporting()
{
	if (m.report > 0)
	{
		logger.info('will report stats every '+m.report+' second' + (m.report>1?'s':''));
		requests = [];
		startMonitoring(m.report*1000);		
	}
}

function lengthHandler(len, res)
{
	if (len > 0 && res.statusCode == 200 || res.statusCode == 304)
	{
		totalRequests++;
		requestsSinceLastSend++;
		totalResponseDataSize+=len;
		responseSizeSinceLastSend+=len;
		if (!res._serviced)
		{
			var key = res.req.url.replace(/\./g,'_~_');
			requestsByAPI[key] = (requestsByAPI[key]||0)+1;
			if (requests)
			{
				requests.push({date:new Date(),url:key,size:len});
			}
		}
	}
	res.removeListener('length', lengthHandler);
}

function status(req,res,next)
{
	res.json({success:1});
}

function length(req,res,next)
{
	res.on('length',lengthHandler);
	return next();
}

function request(req,data)
{
	// make sure the key doesn't have . since you can't serialize a key with that in mongo
	var key = req.serviceMethod+'@'+req.service.version.replace(/\./g,'_~_');
	requestsByAPI[key] = (requestsByAPI[key]||0)+1;

	totalRequestDataSize+=data.length;
	dataSizeSinceLastSend+=data.length;

	if (requests)
	{
		requests.push({date:new Date(),url:key,size:data.length});
	}
}

function responseTime(req,res,next)
{
    var start = new Date;
    if (res._responseTime) return next();
    res._responseTime = start;

    res.on('header', function(header){
      	var duration = new Date - start;
	  	totalRequestDuration += duration;
	  	requestDurationLastSend += duration;
      	res.setHeader('X-Response-time', duration + 'ms');
    });

    next();
}

function performShutdown(callback)
{
	var globalConfig = u.getGlobalConfig(), defaultConfig = u.getDefaultConfig();

	var url = (globalConfig.publishHost || defaultConfig.publishHost) + ':' +
		(globalConfig.publishPort || defaultConfig.publishPort) + '/node-boot-down/' + m.myIP + '/' + m.port;

	var opts = urllib.parse(url);
	opts.method = 'GET';
	if (opts.protocol == 'http:') {
		hserver = require('http');
	} else if (opts.protocol == 'https:') {
		hserver = require('https');
	} else {
		u.die('Unrecognized protocol. Please check your configuration items.');
	}
	var auth = generateAuthToken(opts.path,m.myIP,m.port);
	opts.headers = {'Authorization':auth};

	hserver.request(opts,function(res)
	{
		if (callback)callback(null);
	})
	.on('error',function(e)
	{
		// ignore
		if (callback)callback(e);
	})
	.end();
}

function performUpdate (booting, callback)
{
	var globalConfig = u.getGlobalConfig(), defaultConfig = u.getDefaultConfig();

	//TODO: do oauth

	var url = (globalConfig.publishHost || defaultConfig.publishHost) + ':' +
		(globalConfig.publishPort || defaultConfig.publishPort) + '/node-' + (booting?'boot-up':'update') + '/' + m.myIP + '/' + m.port;

	// append our metadata until the end of our url
	if (metadata)
	{
		url += '?' + querystring.stringify(metadata);
	}

	var opts = urllib.parse(url);
	opts.method = 'GET';
	if (opts.protocol == 'http:') {
		hserver = require('http');
	} else if (opts.protocol == 'https:') {
		hserver = require('https');
	} else {
		u.die('Unrecognized protocol. Please check your configuration items.');
	}
	var auth = generateAuthToken(opts.path,m.myIP,m.port);
	opts.headers = {'Authorization':auth};

	hserver.request(opts,function(res)
	{
		if (res.statusCode==204)
		{
			logger.info('no apps ready to deploy. will try again in 1 min');
			setTimeout(function()
			{
				performUpdate(booting,callback);	
			},60000);
			// this error code means we don't have any pending apps to
			// boot, we should effective try again later
			return;
		}

		if (res.statusCode!=200)
		{
			u.die('Error received at '+url+', status code ='+res.statusCode);
		}

		var fp = path.join(m.publishPath, 'app.tar.gz');
		var stream = fs.createWriteStream(fp);
		var error = false;

		res.pipe(stream)
		   .on("error", function(err){
		   		console.error(err);
		   		error = true;
		});

		res.on("end",function()
		{
			if (!error)
			{
				stream = fs.createReadStream(fp);

				stream.pipe(zlib.createGunzip())
				  .on("error",function(err) {
					logger.error('error on gunzip '+err);
					error = true;
				  })
				  .on("end", function() {
				  })
				  .pipe(tar.Extract({ path: m.publishPath }))
				  .on("error", function (err) 
				  {
				    logger.error("error on tar "+err);
					error = true;
				  })
				  .on("entry", function(e){
					logger.debug('extracting->'+path.join(m.publishPath,e.props.path));
				  })
				  .on("end", function () 
				  {
						try {
                            fs.unlinkSync(fp);
                        } catch (e) {
                            logger.warn('Failed to remove file ' + fp + ', '+e);
                        }
                        if (!error)
					  	{
					  		m.reloadApp();
					  	}
					  	if (callback)
					  	{
					  		callback(error);
					  	}
				  });
			}
		});

	})
	.on('error',function(e)
	{
		(booting?logger.error:u.die)('Error connecting to update server at '+opts.host+'. '+e);
	})
	.end();
}

//---- public interfaces
exports.setup = function(mod, callback)
{
	m = mod;

	process.on('SIGINT', function() 
	{
		performShutdown(function(err)
		{
			process.exit(0);
		});
	});

	findNextController(m, function(error,meta)
	{
		if (error)
		{
			logger.error(error);
			return callback(error);
		}

		metadata = meta;
		startReporting();

		m.on('start',function(app)
		{
			// handles measuring requests and metadata for reporting
			app.use(length);

			// modified version of response time which will also track
			// and report latency metrics
			app.use(responseTime);

			// this is used to just let anyone know that we're OK
			app.get('/-status',status);
		});

		m.reloadApp();

		callback(null,metadata);
	});
};

exports.netBoot = function(callback)
{
	var complete = function(error)
	{
		if (error)
		{
			logger.error(error);
			return;
		}
		temp.mkdir('nettle',function(err,dir)
		{
			m.publishPath = dir;
			performUpdate(true, callback);

			function rmdir()
			{
				wrench.rmdirSyncRecursive(dir,true);
			}
			process.on('SIGINT', rmdir);
			process.on('exit',rmdir);
		});
	};

	if (controller.netBoot)
	{
		controller.netBoot(complete);
	}
	else
	{
		complete();
	}
};

