var path = require('path'),
    u = require('../util'),
    fs = require('fs'),
    logger = require('../logger'),
    request = require('request'),
    HandleResult = require('./handleResult'),
    post = require('../post'),
    cli = require('../cli'),
	_ = require('underscore')
    ;

exports.run = function(args, program) {
    var globalConfig = u.getGlobalConfig(),
        defaultConfig = u.getDefaultConfig(),
        proxy = u.getProxy();

    if(proxy) {
        logger.debug('ACS CLI is using proxy: ' + proxy.server);
        proxy = proxy.url;
    }
    if(globalConfig.publishHost && !program.isCallback) {
        console.log(String(('Admin Hostname: ' + globalConfig.publishHost).grey));
    }

	// attach our authentication
	var cookie = globalConfig.cookie ? String(globalConfig.cookie).split(';')[0] || [ 'connect-sid', '' ].join('=') : '';

	var host = globalConfig.publishHost || defaultConfig.publishHost,
		port = globalConfig.publishPort || defaultConfig.publishPort,
		p = '/publish/',
		url = host + ':' + port + p;

	if(program.list_versions) {
		checkVersions();
	} else if(program.set_active_version) {
		changeVersion();
	} else if(program.git) {
		publishFromGit();
	} else if(program.force) {
		forcePublish();
	} else {
		publishFromDir()
	}

	function checkVersions() {
		var name = program.list_versions === true ? null : program.list_versions,
			appname = u.getAppName(args, program, name);

		url += appname;

		if(program.org) {
			url += ('?orgid=' + program.org);
		}

		var HR = new HandleResult();
		HR.succeed = function(response, result) {
			console.log(result.message);
		};

		request({
			uri: url,
			method: 'GET',
			proxy: proxy,
			headers: {
				'Cookie': cookie,
				'Content-Type': 'application/x-www-form-urlencoded'
			}
		}, HR.handler);
	}

	function changeVersion() {
		var appname = u.getAppName(args, program),
			version = program.set_active_version;
		url += appname + '/' + version;

		if(program.org) {
			url += ('?orgid=' + program.org);
		}

		var HRC = new HandleResult();
		HRC.checkResult = function(response, result) {
			if (!result.success) {
				if(result.message)
					u.die(result.message + ' ' + (result.extended || ''), result.errcode ? result.errcode : 1);
				else
					u.die('Failed to validate the version: ' + result);
			}
			program.confirm('Do you want to deploy version ' +  version + ' published at ' + new Date(result.message) + '? ', function(ok) {
				if(ok) {
					doChange();
				} else {
					process.exit();
				}
			});
		};

		request({
			uri: url,
			method: 'GET',
			proxy: proxy,
			headers: {
				'Cookie': cookie,
				'Content-Type': 'application/x-www-form-urlencoded'
			}
		}, HRC.handler);


		function doChange() {

			var HR = new HandleResult();

			request({
				uri: url,
				method: 'POST',
				proxy: proxy,
				headers: {
					'Cookie': cookie,
					'Content-Type': 'application/x-www-form-urlencoded'
				}
			}, HR.handler);
		}
	}


    /**
     * When user uses '--force' option with app name as parameter
     * we don't know whether the app was published from git or from local dir
     * In this case, we'll sent a request first to check the app publish location
     * If the app was publish from git, then we'll use the git config stored in
     * the server to redo the publish
     * otherwise, we'll do the normal publish processes for local dir
     */
    function forcePublish() {
        var name = program.force === true ? null : program.force,
            appname = u.getAppName(args, program, name);

        url += appname + '/1';

        if(program.org) {
            url += ('?orgid=' + program.org);
        }

        var options = {
            uri: url,
            method: 'PUT',
            proxy: proxy,
            headers: {
                'Cookie': cookie,
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        };

        if(args.length === 2) {
            options.auth =  {
                user: args[0],
                password: args[1]
            };
        }

        var Request = request(options, function(error, response, body) {
            if (error) {
                u.die(u.getConnectionErrorMsg(error, body));
            }
            if (response.statusCode == 503) {
                u.die("Admin server is currently unavailable.");
            }
            if (response.statusCode == 404) {
                u.die(body);
            }
        });

        var buf = '', progress = '';
        Request.on('data', function(b) {
            progress += b;
            var n, line;
            while((n = progress.indexOf('|')) !== -1) {
                if(n == 0) {
                    progress = progress.substring(1);
                } else {
                    line = progress.substring(0, n);
                    progress = progress.substring(n);
                    if(line.indexOf('{') !== 0) {
                        console.log(line);
                    } else {
                        buf += line;
                    }
                }
            }
        });

        Request.on('end', function() {
            buf += progress;
            var result = {};
            try {
                result = JSON.parse(buf);
            } catch (e) {
                u.die(buf);
            }
            if(result.success) {
                handlePublishResult(null, buf);
            } else {
                // for 201(app not found) and 288(app was not published from git) we should call normal publish
                if (result.errcode === 201 || result.errcode === 288) {
                    // reset url here
                    url = host + ':' + port + p;
                    publishFromDir();
                } else if( result.errcode && result.errcode == 100 ) {
                    // stop spinner if current command is 'publish'
                    u.requireLogin(function() {
                        require('./' + publish).run(args, program);
                    });

                } else {
                    console.log();
                    u.die(result.message, result.errcode ? result.errcode : 1);
                }
            }
        });

    }


    function publishFromGit() {
		var gitConfig = program.git;
		// the user has two ways to specify the git config
		//  1. acs publish â€”git repo=https://github.com/rdong/gitTestApp.git, branch=master, username=uname, access_token=****, npm_username=npmuname, npm_password=****
		//  2. acs publish --git git.config
		//      the content of the git.config should be like below:
		//		{
		//			"repo": "https://github.com/appcelerator/myapp.git",
		//			"branch": "1.1.1",
		//			"access_token": "your_access_token" // your personal-access-tokens generated from git hub, used as password
		//		}

		var configObj = {};
		var eqSign = gitConfig.indexOf('=');
		if (eqSign == -1) {
			var dir = program.dir || process.cwd();
			var f = path.join(dir, gitConfig);
			if (!u.exists(f)) {
				u.die('Could not find git configuration file. Please specify a valid git configuration file.'.red);
			} else {
				var result = u.readAndValidateGitConfig(f);
				if(result.success == false){
					u.die(result.message);
				}
				configObj = result.config;
			}
		} else {
			var vars = program.git.split(',');
			for(var i = 0; i<vars.length; i++) {
				var arg = vars[i];
				eqSign = arg.indexOf('=');
				if(eqSign == -1) {
					u.die('Invalid git configuration item: ' + arg);
				}
				var key = arg.substring(0, eqSign);
				if(key.length = 0) {
					u.die('Invalid git configuration item: ' + arg);
				}
				var value = arg.substring(eqSign+1, arg.length);
				if(value.length == 0) {
					u.die('Invalid git configuration item: ' + arg);
				}
				configObj[key] = value;
			}
			if(!configObj['repo']) {
				u.die('Invalid git configuration, should have \'repo\'');
			}
		}

		url += program.force ? 1 : 0;

		if(program.org) {
			url += ('?orgid=' + program.org);
		}

		doPublish(url, configObj);

		function doPublish(url, configObj) {

			var options = {
				uri: url,
				method: 'POST',
				proxy: proxy,
				headers: {
					'Cookie': cookie,
					'Content-Type': 'application/json'
				}
			};

			var newConfigObj = _.clone(configObj);

			if(args.length === 2) {
				options.auth =  {
					user: args[0],
					password: args[1]
				};
			}

			options.body = JSON.stringify(newConfigObj);

			var Request = request(options, function(error, response, body) {
				if (error) {
					u.die(u.getConnectionErrorMsg(error, body));
				}
				if (response.statusCode == 503) {
					u.die("Admin server is currently unavailable.");
				}
				if (response.statusCode == 404) {
					u.die(body);
				}
			});

			var buf = '', progress = '';
			Request.on('data', function(b) {
				progress += b;
				var n, line;
				while((n = progress.indexOf('|')) !== -1) {
					if(n == 0) {
						progress = progress.substring(1);
					} else {
						line = progress.substring(0, n);
						progress = progress.substring(n);
						if(line.indexOf('{') !== 0) {
							console.log(line);
						} else {
							buf += line;
						}
					}
				}
			});

			Request.on('end', function() {
				buf += progress;
				var result = {};
				try {
					result = JSON.parse(buf);
				} catch (e) {
					u.die(buf);
				}
				if(result.success) {
					handlePublishResult(null, buf);
				} else {
					if (result.errcode === 201 || result.errcode === '201' ||
						result.errcode === 'ENOEXISTS') {
						var appname;
						if(result.extend && result.extend.name) {
							appname = result.extend.name;
						} else {
							u.die("Can not get the name of app");
						}
						// prompt for creating a new app
						program.confirm('It looks like you don\'t have this app created on Node.ACS yet. \nDo you want to create it for publishing now (yes/no)? ', function (ok) {
							if (ok) {
								console.log('Creating new Node.ACS app...');
								var newAppURL = (globalConfig.publishHost || defaultConfig.publishHost) + ':' +
									(globalConfig.publishPort || defaultConfig.publishPort) +
									'/create/' + appname;
								createNewApp(newAppURL, null, url, null, null, null, null, newConfigObj, 'git', doPublish);
							} else {
								process.exit();
							}
						});
					} else if( result.errcode && result.errcode == 100 ) {
						// stop spinner if current command is 'publish'
						u.requireLogin(function() {
							require('./' + publish).run(args, program);
						});

					} else {
						console.log();
						u.die(result.message, result.errcode ? result.errcode : 1);
					}
				}
			});
		}
	}

	function publishFromDir() {

		var dir = program.dir || process.cwd();
		var f = path.join(dir, 'package.json');
		if (!u.exists(f)) {
			u.die('Couldn\'t find app directory for publishing');
		}

		var config = {};
		// validate package.json

		var result = u.readAndValidateConfig(f);
		if(result.success == false){
			u.die(result.message);
		}
		config = result.config;

		if (!config.version) { u.die('Please provide a valid version for your app in the package.json before continuing'.red); }
		var version = config.version;

		if (config.npmAuthentication === true) {
			var auth = u.getNPMAuth();
			if (auth && args.length === 0) {
				doPublish(auth.user, auth.password);
			} else {
				process.stdin.resume && process.stdin.resume();
				u.getUsername(args, 'npm username:', function uncb(un)
				{
					if(!un) {
						u.getUsername(args, 'npm username:', uncb);
						return;
					}
					u.getPassword(args, 'npm password:', function pwcb(pw)
					{
						if(!pw) {
							u.getPassword(args, 'npm password:', pwcb);
							return;
						}

						doPublish(un, pw);
					});
				});
			}
		} else {
			doPublish();
		}

		function doPublish(un, pw) {

			url += [ config.name, config.version, (program.force ? 1 : 0) ].join('/');

			if(program.org) {
				url += ('?orgid=' + program.org);
			}

			cli.spinner('Preparing application for publish...');

			var dirs = [ dir ];

			var HR = new HandleResult();
			HR.cli = cli;
			HR.reqParams=['publish', args, program];
			HR.checkResult = function(response, result) {
				if (result.success) {
					cli.spinner('Preparing application for publish... done\n', true);
					publish(dirs, url, config, cookie, version, un, pw);
				} else {
					// TODO, the string comparison here can probably be dropped
					if (result.errcode === 201 || result.errcode === '201' ||
						result.errcode === 'ENOEXISTS') {
						// prompt for creating a new app
						cli.spinner('Preparing application for publish... \n', true);
						program.confirm('It looks like you don\'t have this app created on Node.ACS yet. \nDo you want to create it for publishing now (yes/no)? ', function (ok) {
							if (ok) {
								console.log('Creating new Node.ACS app...');
								var newAppURL = (globalConfig.publishHost || defaultConfig.publishHost) + ':' +
									(globalConfig.publishPort || defaultConfig.publishPort) +
									'/create/' + config.name;
								createNewApp(newAppURL, dirs, url, config, version, un, pw, null, 'dir', publish);
							} else {
								process.exit();
							}
						});
					} else {
						console.log();
						u.die(result.message, result.errcode ? result.errcode : 1);
					}
				}
			};

			request({
				uri: url,
				method: 'GET',
				proxy: proxy,
				headers: {
					'Cookie': cookie,
					'Content-Type': 'application/x-www-form-urlencoded'
				}
			}, HR.handler);
		}
	}

	function createNewApp(newAppURL, dirs, url, config, version, un, pw, configObj, where, callback) {
		var HR2 = new HandleResult();
		HR2.errorMessage = 'Unable to create new app';
		HR2.checkResult = function (response, result) {
			if (!result.success) {
				// TODO, the string comparison here can probably
				// be dropped
				if (result.errcode === 265 ||
					result.errcode === '265') {
					// prompt for choose an organization
					var orgs = [], orgids = [];
					for (var orgid in result.organizations) {
						orgids.push(orgid);
						var org = '';
						org += result.organizations[orgid].name;
						org += (' (' + orgid + ')');
						orgs.push(org);
					}

					console.log('You belong to more than one organization. Please choose one for the app.');
					program.choose(orgs, function (i) {
						var orgid = orgids[i];
						console.log('Creating new Node.ACS app for organization ' + orgs[i] + '...');
						request({
							uri:newAppURL,
							method:'POST',
							proxy:proxy,
							headers:{
								'Cookie':cookie,
								'Content-Type':'application/json'
							},
							body:JSON.stringify({orgid:orgid})
						}, HR2.handler);

					});
				} else {
					var message = result.extended || result.message;
					u.die('Unable to create new app: ' + message, result.errcode ? result.errcode : 1);
				}
			} else {
				cli.spinner('Creating new Node.ACS app...done', true);
				cli.spinner('Preparing application for publish... done\n', true);
				if(where === 'dir') {
					callback(dirs, url, config, cookie, version, un, pw);
				} else {
					callback(url, configObj);
				}
			}
		};

		var body = {};
		if (program.org) {
			body.orgid = program.org;
		}

		request({
			uri:newAppURL,
			method:'POST',
			proxy:proxy,
			headers:{
				'Cookie':cookie,
				'Content-Type':'application/json'
			},
			body:JSON.stringify(body)
		}, HR2.handler);

	}
};

function publish(dirs, url, config, cookie, version, un, pw) {
    post.sendTarGz(dirs, url, config.version, un, pw, handlePublishResult, cookie);
}

function handlePublishResult(err, buf) {
	if (err) {
		u.die('Error publishing app. ' + err);
	}
	try {
		var result = {};
		try {
			result = JSON.parse(buf);
		} catch (e) {
			u.die(buf);
		}
		if (!result.success) {
			if (result.meta) {
				console.log();
				u.die('Publish Error: ' + result.meta.message, result.errcode ? result.errcode : 1);
			} else {
				u.die('Publish Error: ' + result.message, result.errcode ? result.errcode : 1);
			}
		} else {
			if(result.name && result.version) {
				console.log('App ' + result.name.blue + ' version ' + result.version.blue + ' published.');
			} else {
				console.log('App published.');
			}
			if (result.url) {
				console.log('App will be available at ' + result.url.cyan);
				process.exit();
			}
		}
	} catch (E) {
		u.die('Error retrieving result ' + E + '. Result was ' + buf);
	}
}
